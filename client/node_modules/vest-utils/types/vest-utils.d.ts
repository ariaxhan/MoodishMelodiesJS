type DropFirst<T extends unknown[]> = T extends [
    unknown,
    ...infer U
] ? U : never;
type Stringable = string | CB<string>;
type CB<T = any, Args extends TArgs = TArgs> = (...args: Args) => T;
type ValueOf<T> = T[keyof T];
type Nullish<T = void> = Nullable<T> | Maybe<T>;
type Nullable<T> = T | null;
type Maybe<T> = T | undefined | void;
type OneOrMoreOf<T> = T | T[];
type DynamicValue<T, Args extends TArgs = TArgs> = T | CB<T, Args>;
type BlankValue = Maybe<"">;
type TArgs = any[];
/**
 * Creates a cache function
 */
declare function createCache<T = unknown>(maxSize?: number): CacheApi<T>;
type CacheApi<T = unknown> = {
    (deps: unknown[], cacheAction: (...args: unknown[]) => T): T;
    get(deps: unknown[]): Nullable<[
        unknown[],
        T
    ]>;
    invalidate(item: any): void;
};
type OnReturn = {
    off: CB<void>;
};
type BusType = {
    on: (event: string, handler: CB) => OnReturn;
    emit: (event: string, data?: any) => void;
};
type TinyState<S> = () => [
    value: S,
    setValue: (next: SetValueInput<S>) => void,
    resetValue: () => void
];
type SetValueInput<S> = DynamicValue<S, [
    prev: S
]>;
declare function isNullish(value: any): value is Nullish;
declare const isNotNullish: (value: any) => boolean;
declare function asArray<T>(possibleArg: T | T[]): T[];
declare function callEach(arr: CB[]): void;
/**
 * A safe hasOwnProperty access
 */
declare function hasOwnProperty<T>(obj: T, key: string | number | symbol): key is keyof T;
declare function isPromise(value: any): value is Promise<unknown>;
declare function optionalFunctionValue<T>(value: DynamicValue<T>, ...args: unknown[]): T;
declare const _default: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2 extends {}, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
};
declare function defaultTo<T>(value: DynamicValue<Nullish<T>>, defaultValue: DynamicValue<T>): T;
declare function invariant(condition: any, 
// eslint-disable-next-line @typescript-eslint/ban-types
message?: String | Stringable): asserts condition;
declare function isStringValue(v: unknown): v is string;
declare function bindNot<T extends (...args: any[]) => unknown>(fn: T): (...args: Parameters<T>) => boolean;
declare function either(a: unknown, b: unknown): boolean;
declare function isBoolean(value: unknown): value is boolean;
declare function deferThrow(message?: string): void;
declare namespace bus {
    type DropFirst<T extends unknown[]> = T extends [
        unknown,
        ...infer U
    ] ? U : never;
    type Stringable = string | CB<string>;
    type CB<T = any, Args extends TArgs = TArgs> = (...args: Args) => T;
    type ValueOf<T> = T[keyof T];
    type Nullish<T = void> = Nullable<T> | Maybe<T>;
    type Nullable<T> = T | null;
    type Maybe<T> = T | undefined | void;
    type OneOrMoreOf<T> = T | T[];
    type DynamicValue<T, Args extends TArgs = TArgs> = T | CB<T, Args>;
    type BlankValue = Maybe<"">;
    type TArgs = any[];
    function createBus(): BusType;
    type OnReturn = {
        off: CB<void>;
    };
    type BusType = {
        on: (event: string, handler: CB) => OnReturn;
        emit: (event: string, data?: any) => void;
    };
}
declare const seq: CB<string, any[]>;
declare function genSeq(namespace?: string): CB<string>;
declare function isFunction(value: unknown): value is (...args: unknown[]) => unknown;
declare function mapFirst<T>(array: T[], callback: (item: T, breakout: (conditional: boolean, value: unknown) => void, index: number) => unknown): any;
declare function greaterThan(value: number | string, gt: number | string): boolean;
declare function longerThan(value: string | unknown[], arg1: string | number): boolean;
declare function isNumeric(value: string | number): boolean;
declare const isNotNumeric: (value: string | number) => boolean;
declare function isObject(v: any): v is Record<any, any>;
declare function lengthEquals(value: string | unknown[], arg1: string | number): boolean;
declare const lengthNotEquals: (value: string | unknown[], arg1: string | number) => boolean;
declare function numberEquals(value: string | number, eq: string | number): boolean;
declare const numberNotEquals: (value: string | number, eq: string | number) => boolean;
declare function isNull(value: unknown): value is null;
declare const isNotNull: (value: unknown) => boolean;
declare function isUndefined(value?: unknown): value is undefined;
declare const isNotUndefined: (value?: unknown) => boolean;
// The module is named "isArrayValue" since it
// is conflicting with a nested npm dependency.
// We may need to revisit this in the future.
declare function isArray(value: unknown): value is Array<unknown>;
declare const isNotArray: (value: unknown) => boolean;
declare function isEmpty(value: unknown): boolean;
declare const isNotEmpty: (value: unknown) => boolean;
declare function isPositive(value: number | string): boolean;
declare function text(str: string, ...substitutions: Array<unknown>): string;
declare const STATE_WILD_CARD = "*";
type TStateWildCard = typeof STATE_WILD_CARD;
type TStateMachine<S extends string, A extends string> = {
    initial: S;
    states: Partial<{
        [key in S & TStateWildCard]: {
            [key in A]?: S | [
                S,
                CB<boolean, [
                    payload?: any
                ]>
            ];
        };
    }>;
};
type TStateMachineApi<S extends string, A extends string> = {
    getState: CB<S>;
    transition: (action: A, payload?: any) => void;
    staticTransition: (from: S, action: A, payload?: any) => S;
};
declare function StateMachine<S extends string, A extends string>(machine: TStateMachine<S, A>): TStateMachineApi<S, A>;
declare function nonnullish<T>(value: Nullish<T>, error?: string): T;
declare namespace tinyState {
    type DropFirst<T extends unknown[]> = T extends [
        unknown,
        ...infer U
    ] ? U : never;
    type Stringable = string | CB<string>;
    type CB<T = any, Args extends TArgs = TArgs> = (...args: Args) => T;
    type ValueOf<T> = T[keyof T];
    type Nullish<T = void> = Nullable<T> | Maybe<T>;
    type Nullable<T> = T | null;
    type Maybe<T> = T | undefined | void;
    type OneOrMoreOf<T> = T | T[];
    type DynamicValue<T, Args extends TArgs = TArgs> = T | CB<T, Args>;
    type BlankValue = Maybe<"">;
    type TArgs = any[];
    function createTinyState<S>(initialValue: SetValueInput<S>): TinyState<S>;
    type TinyState<S> = () => [
        value: S,
        setValue: (next: SetValueInput<S>) => void,
        resetValue: () => void
    ];
    type SetValueInput<S> = DynamicValue<S, [
        prev: S
    ]>;
}
// eslint-disable-next-line @typescript-eslint/ban-types
declare function StringObject(value?: Stringable): String;
// eslint-disable-next-line @typescript-eslint/no-empty-function
declare function noop(): void;
export { createCache as cache, CacheApi, BusType, TinyState, isNullish, isNotNullish, asArray, callEach, hasOwnProperty, isPromise, optionalFunctionValue, _default as assign, defaultTo, invariant, isStringValue, bindNot, either, isBoolean, deferThrow, bus, seq, genSeq, isFunction, mapFirst, greaterThan, longerThan, isNumeric, isNotNumeric, isObject, lengthEquals, lengthNotEquals, numberEquals, numberNotEquals, isNull, isNotNull, isUndefined, isNotUndefined, isArray, isNotArray, isEmpty, isNotEmpty, isPositive, text, TStateMachine, StateMachine, nonnullish, tinyState, StringObject, noop };
export type { DropFirst, Stringable, CB, ValueOf, Nullish, Nullable, Maybe, OneOrMoreOf, DynamicValue, BlankValue };
//# sourceMappingURL=vest-utils.d.ts.map