function bindNot(fn) {
    return (...args) => !fn(...args);
}

function isNumeric(value) {
    const str = String(value);
    const num = Number(value);
    const result = !isNaN(parseFloat(str)) && !isNaN(Number(value)) && isFinite(num);
    return Boolean(result);
}
const isNotNumeric = bindNot(isNumeric);

function numberEquals(value, eq) {
    return isNumeric(value) && isNumeric(eq) && Number(value) === Number(eq);
}
const numberNotEquals = bindNot(numberEquals);

function lengthEquals(value, arg1) {
    return numberEquals(value.length, arg1);
}
const lengthNotEquals = bindNot(lengthEquals);

function greaterThan(value, gt) {
    return isNumeric(value) && isNumeric(gt) && Number(value) > Number(gt);
}

function longerThan(value, arg1) {
    return greaterThan(value.length, arg1);
}

/**
 * Creates a cache function
 */
function createCache(maxSize = 1) {
    const cacheStorage = [];
    const cache = (deps, cacheAction) => {
        const cacheHit = cache.get(deps);
        // cache hit is not null
        if (cacheHit)
            return cacheHit[1];
        const result = cacheAction();
        cacheStorage.unshift([deps.concat(), result]);
        if (longerThan(cacheStorage, maxSize))
            cacheStorage.length = maxSize;
        return result;
    };
    // invalidate an item in the cache by its dependencies
    cache.invalidate = (deps) => {
        const index = findIndex(deps);
        if (index > -1)
            cacheStorage.splice(index, 1);
    };
    // Retrieves an item from the cache.
    cache.get = (deps) => cacheStorage[findIndex(deps)] || null;
    return cache;
    function findIndex(deps) {
        return cacheStorage.findIndex(([cachedDeps]) => lengthEquals(deps, cachedDeps.length) &&
            deps.every((dep, i) => dep === cachedDeps[i]));
    }
}

function isNull(value) {
    return value === null;
}
const isNotNull = bindNot(isNull);

function isUndefined(value) {
    return value === undefined;
}
const isNotUndefined = bindNot(isUndefined);

function isNullish(value) {
    return isNull(value) || isUndefined(value);
}
const isNotNullish = bindNot(isNullish);

function asArray(possibleArg) {
    return [].concat(possibleArg);
}

function callEach(arr) {
    return arr.forEach(fn => fn());
}

/**
 * A safe hasOwnProperty access
 */
function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function isFunction(value) {
    return typeof value === 'function';
}

function isPromise(value) {
    return !!value && isFunction(value.then);
}

function optionalFunctionValue(value, ...args) {
    return isFunction(value) ? value(...args) : value;
}

var assign = Object.assign;

function defaultTo(value, defaultValue) {
    var _a;
    return (_a = optionalFunctionValue(value)) !== null && _a !== void 0 ? _a : optionalFunctionValue(defaultValue);
}

function invariant(condition, 
// eslint-disable-next-line @typescript-eslint/ban-types
message) {
    if (condition) {
        return;
    }
    // If message is a string object (rather than string literal)
    // Throw the value directly as a string
    // Alternatively, throw an error with the message
    throw message instanceof String
        ? message.valueOf()
        : new Error(message ? optionalFunctionValue(message) : message);
}

function isStringValue(v) {
    return String(v) === v;
}

function either(a, b) {
    return !!a !== !!b;
}

function isBoolean(value) {
    return !!value === value;
}

function deferThrow(message) {
    setTimeout(() => {
        throw new Error(message);
    }, 0);
}

const EVENT_WILDCARD = '*';
function createBus() {
    const listeners = {};
    return {
        emit(event, data) {
            getListeners(event)
                .concat(getListeners(EVENT_WILDCARD))
                .forEach(handler => {
                handler(data);
            });
        },
        on(event, handler) {
            listeners[event] = getListeners(event).concat(handler);
            return {
                off() {
                    listeners[event] = getListeners(event).filter(h => h !== handler);
                },
            };
        },
    };
    function getListeners(event) {
        return listeners[event] || [];
    }
}

var bus = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createBus: createBus
});

/**
 * @returns a unique numeric id.
 */
const seq = genSeq();
function genSeq(namespace) {
    return ((n) => () => `${namespace ? namespace + '_' : ''}${n++}`)(0);
}

function mapFirst(array, callback) {
    let broke = false;
    let breakoutValue = null;
    for (let i = 0; i < array.length; i++) {
        callback(array[i], breakout, i);
        if (broke) {
            return breakoutValue;
        }
    }
    function breakout(conditional, value) {
        if (conditional) {
            broke = true;
            breakoutValue = value;
        }
    }
}

function isObject(v) {
    return typeof v === 'object' && !isNullish(v);
}

// The module is named "isArrayValue" since it
// is conflicting with a nested npm dependency.
// We may need to revisit this in the future.
function isArray(value) {
    return Boolean(Array.isArray(value));
}
const isNotArray = bindNot(isArray);

function isEmpty(value) {
    if (!value) {
        return true;
    }
    else if (hasOwnProperty(value, 'length')) {
        return lengthEquals(value, 0);
    }
    else if (isObject(value)) {
        return lengthEquals(Object.keys(value), 0);
    }
    return false;
}
const isNotEmpty = bindNot(isEmpty);

function isPositive(value) {
    return greaterThan(value, 0);
}

const regexp = /{(.*?)}/g;
function text(str, ...substitutions) {
    const first = substitutions[0];
    if (isObject(first)) {
        return str.replace(regexp, (placeholder, key) => {
            var _a;
            return `${(_a = first[key]) !== null && _a !== void 0 ? _a : placeholder}`;
        });
    }
    const subs = [...substitutions];
    return str.replace(regexp, placeholder => {
        return `${isEmpty(subs) ? placeholder : subs.shift()}`;
    });
}

const STATE_WILD_CARD = '*';
function StateMachine(machine) {
    let state = machine.initial;
    const api = { getState, transition, staticTransition };
    return api;
    function getState() {
        return state;
    }
    function transition(action, payload) {
        return (state = staticTransition(state, action, payload));
    }
    // eslint-disable-next-line complexity
    function staticTransition(from, action, payload) {
        var _a, _b, _c;
        const transitionTo = (_b = (_a = machine.states[from]) === null || _a === void 0 ? void 0 : _a[action]) !== null && _b !== void 0 ? _b : 
        // @ts-expect-error - This is a valid state
        (_c = machine.states[STATE_WILD_CARD]) === null || _c === void 0 ? void 0 : _c[action];
        let target = transitionTo;
        if (Array.isArray(target)) {
            const [, conditional] = target;
            if (!conditional(payload)) {
                return from;
            }
            target = target[0];
        }
        if (!target || target === from) {
            return from;
        }
        return target;
    }
}

function nonnullish(value, error) {
    invariant(!isNullish(value), error);
    return value;
}

function createTinyState(initialValue) {
    let value;
    resetValue();
    return () => [value, setValue, resetValue];
    function setValue(nextValue) {
        value = optionalFunctionValue(nextValue, value);
    }
    function resetValue() {
        setValue(optionalFunctionValue(initialValue));
    }
}

var tinyState = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createTinyState: createTinyState
});

// eslint-disable-next-line @typescript-eslint/ban-types
function StringObject(value) {
    return new String(optionalFunctionValue(value));
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() { }

export { StateMachine, StringObject, asArray, assign, bindNot, bus, createCache as cache, callEach, defaultTo, deferThrow, either, genSeq, greaterThan, hasOwnProperty, invariant, isArray, isBoolean, isEmpty, isFunction, isNotArray, isNotEmpty, isNotNull, isNotNullish, isNotNumeric, isNotUndefined, isNull, isNullish, isNumeric, isObject, isPositive, isPromise, isStringValue, isUndefined, lengthEquals, lengthNotEquals, longerThan, mapFirst, nonnullish, noop, numberEquals, numberNotEquals, optionalFunctionValue, seq, text, tinyState };
//# sourceMappingURL=vest-utils.development.js.map
